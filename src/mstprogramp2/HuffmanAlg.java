package mstprogramp2;

import java.util.*;

/**
 * HuffmanAlg
 * Implements Huffman encoding/decoding for uppercase letters A-Z.
 * @author donia
 */
public class HuffmanAlg {
    // Priority Queue to store nodes (smaller frequency has higher priority)
    private PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.frequency, b.frequency));
    private int[] freq = new int[26];      // Store the frequency for each element (A to Z)
    private String[] code = new String[26];// Store the code generated by Huffman encoder
    public Node root;                      // Root of Huffman tree
    private String decoded = "";           // Decoded text 
    private String encoded = "";           // Encoded text

    /**
     * Read the text entered to Huffman Alg, compute the frequency for each letter 
     * @param text the text aimed to be encoded 
     */
    private void readText(String text) {
        if (text == null) return; // handle null input

        // reset frequency array
        for (int i = 0; i < freq.length; i++) {
            freq[i] = 0;
        }

        // Count frequency of characters Aâ€“Z
        for (char ch : text.toCharArray()) { // walk through each letter in the text 
            int ind = ch - 'A';              // use ASCII code as index start from A to Z
            if (ind >= 0 && ind < 26) {      // condition checking for unexpected characters
                freq[ind] += 1;              // frequency counter 
            }
        }
    }
    
    /**
     * Create encoded text using Huffman Algorithm (calls helper methods)  
     * @param text the text to be encoded
     * @return Encoded text 
     */
    public String huffmanEncoder(String text) {

        // reset code[]
        for (int i = 0; i < code.length; i++) {
            code[i] = null;
        }

        // Call helper methods to create the encoded text 
        readText(text); 
        creatTree();
        generateCode(root, "");

        // Use StringBuilder to efficiently build the encoded bitstring
        StringBuilder sb = new StringBuilder(text.length() * 2);
        encoded = "";

        // loop through the text characters 
        for (int i = 0; i < text.length(); i++) {  
            int ind = text.charAt(i) - 'A';   // char index using A as reference in ASCII 
            // if the index is inside the character range and the char has a code 
            if (ind >= 0 && ind < 26 && code[ind] != null) {  
                sb.append(code[ind]);   // append the code to the encoded text 
            }
        }

        encoded = sb.toString();
        return encoded;      // return encoded text
    }
    
    /**
     * Use the frequency[] to create Node objects, add them to Priority Queue pq,
     * then build the Huffman tree based on the pq order 
     */
    private void creatTree() {   
        pq.clear();   

        // Create leaf nodes for characters with freq > 0
        for (int i = 0; i < freq.length; i++) { 
            if (freq[i] > 0) {
                pq.add(new Node((char)(i + 'A'), freq[i])); // create Node and add it to pq
            }  
        }
          if (pq.size() == 1) {  // if the pq has one element leaf
            Node node = pq.poll();
            Node newNode = new Node(null, node.frequency);
            newNode.left = node;
            root = newNode;
            return;
        }
        // Build the tree bottom-up
        while (pq.size() > 1) {
            Node left = pq.poll();   // smallest frequency
            Node right = pq.poll();  // second smallest
            Node newNode = new Node(null, left.frequency + right.frequency); // internal node
            newNode.left = left;     // link parent to left child 
            newNode.right = right;   // link parent to right child 
            pq.add(newNode);         // add the new node back to pq 
        }
        
        root = pq.poll(); // poll the last node from pq and store it in "root"
    }

    /**
     * Generate prefix codes for each leaf node
     * @param node current node in the tree
     * @param charCode prefix code
     */
    private void generateCode(Node node, String charCode) {
        if (node == null) return;
        
        if (node.ch != null) { // if the node is a leaf (internal nodes have null ch)
            int ind = node.ch - 'A'; // use ASCII value of the char
            if (charCode.length() == 0) { // if the node is the only node, give it code "0"
                code[ind] = "0";
            } else {
                code[ind] = charCode; // otherwise assign "charCode"
            }
        }
        // recursively call for left child, append "0" to "charCode" 
        generateCode(node.left, charCode + "0");
        // recursively call for right child, append "1" to "charCode" 
        generateCode(node.right, charCode + "1");
    }
   
    /**
     * Return the original text before applying huffman encoding
     * @param encodedText huffman encoded text 
     * @return Decoded text 
     */
    public String huffmanDecoder(String encodedText ) {  
        decoded = "";
        if (root == null || encodedText.isEmpty()) { // if there is no tree to help decoding
            return decoded;
        }
        
        /**
         * Traverse the tree starting from the root and follow directions based on bits:
         * if the bit is 0 go to the left child, if it is 1 go to the right child.
         * When a leaf node is reached, take "node.ch" and append it to "decoded".
         * Then restart from the root to detect the next character.
         */
        Node node = root;
        for (int i = 0; i < encodedText.length(); i++) {
            char bit = encodedText.charAt(i);
            if (bit == '0') {
                node = node.left;
            } else if (bit == '1') {
                node = node.right; 
            } else {
                continue;
            }
            if (node == null) break;
            if (node.left == null && node.right == null) {
                decoded = decoded + node.ch;
                node = root;
            }
        }
        return decoded;
    }
   
    /**
     * Display table with all characters and their codes 
     */
    public void display(){
        System.out.println(" ____________________________");
        System.out.println("|    Char   |Huffman codeword |");
        System.out.println("|___________|_________________|");
        for (int i=0;i<code.length;i++){
            if(code[i]!=null){
                
                System.out.println("|  " + (char)(i+'A') + "        |      " + code[i] + "     |");
            }
            System.out.println("|_____________________________|");
        }  
    }
}

/**
 * Node class for Huffman tree
 * @author donia
 */
class Node {
    Character ch;     // store node's character
    int frequency;    // store node frequency
    Node left;        // left child
    Node right;       // right child
    String code;      // the created code for character "ch"
    
    /**
     * @param ch the character
     * @param frequency number of times character "ch" appeared in the text
     */
    public Node(Character ch, int frequency) {
        this.ch = ch;
        this.frequency = frequency;
    }
}
